// WARNING: This file has automatically been generated on Wed, 22 May 2024 01:06:30 KST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package rsmi

/*
#cgo linux LDFLAGS: -Wl,--export-dynamic -Wl,--unresolved-symbols=ignore-in-object-files
#include "rocm_smi/rocm_smi.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocRsmi_counter_valueMemory allocates memory for type C.rsmi_counter_value_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_counter_valueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_counter_valueValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_counter_valueValue = unsafe.Sizeof([1]C.rsmi_counter_value_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_counter_value) Ref() *C.rsmi_counter_value_t {
	if x == nil {
		return nil
	}
	return x.ref3d716451
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_counter_value) Free() {
	if x != nil && x.allocs3d716451 != nil {
		x.allocs3d716451.(*cgoAllocMap).Free()
		x.ref3d716451 = nil
	}
}

// Newrsmi_counter_valueRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_counter_valueRef(ref unsafe.Pointer) *rsmi_counter_value {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_counter_value)
	obj.ref3d716451 = (*C.rsmi_counter_value_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_counter_value) PassRef() (*C.rsmi_counter_value_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d716451 != nil {
		return x.ref3d716451, nil
	}
	mem3d716451 := allocRsmi_counter_valueMemory(1)
	ref3d716451 := (*C.rsmi_counter_value_t)(mem3d716451)
	allocs3d716451 := new(cgoAllocMap)
	allocs3d716451.Add(mem3d716451)

	var cvalue_allocs *cgoAllocMap
	ref3d716451.value, cvalue_allocs = (C.uint64_t)(x.value), cgoAllocsUnknown
	allocs3d716451.Borrow(cvalue_allocs)

	var ctime_enabled_allocs *cgoAllocMap
	ref3d716451.time_enabled, ctime_enabled_allocs = (C.uint64_t)(x.time_enabled), cgoAllocsUnknown
	allocs3d716451.Borrow(ctime_enabled_allocs)

	var ctime_running_allocs *cgoAllocMap
	ref3d716451.time_running, ctime_running_allocs = (C.uint64_t)(x.time_running), cgoAllocsUnknown
	allocs3d716451.Borrow(ctime_running_allocs)

	x.ref3d716451 = ref3d716451
	x.allocs3d716451 = allocs3d716451
	return ref3d716451, allocs3d716451

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_counter_value) PassValue() (C.rsmi_counter_value_t, *cgoAllocMap) {
	if x.ref3d716451 != nil {
		return *x.ref3d716451, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_counter_value) Deref() {
	if x.ref3d716451 == nil {
		return
	}
	x.value = (uint64)(x.ref3d716451.value)
	x.time_enabled = (uint64)(x.ref3d716451.time_enabled)
	x.time_running = (uint64)(x.ref3d716451.time_running)
}

// allocRsmi_evt_notification_dataMemory allocates memory for type C.rsmi_evt_notification_data_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_evt_notification_dataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_evt_notification_dataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_evt_notification_dataValue = unsafe.Sizeof([1]C.rsmi_evt_notification_data_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_evt_notification_data) Ref() *C.rsmi_evt_notification_data_t {
	if x == nil {
		return nil
	}
	return x.ref12bb4c74
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_evt_notification_data) Free() {
	if x != nil && x.allocs12bb4c74 != nil {
		x.allocs12bb4c74.(*cgoAllocMap).Free()
		x.ref12bb4c74 = nil
	}
}

// Newrsmi_evt_notification_dataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_evt_notification_dataRef(ref unsafe.Pointer) *rsmi_evt_notification_data {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_evt_notification_data)
	obj.ref12bb4c74 = (*C.rsmi_evt_notification_data_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_evt_notification_data) PassRef() (*C.rsmi_evt_notification_data_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12bb4c74 != nil {
		return x.ref12bb4c74, nil
	}
	mem12bb4c74 := allocRsmi_evt_notification_dataMemory(1)
	ref12bb4c74 := (*C.rsmi_evt_notification_data_t)(mem12bb4c74)
	allocs12bb4c74 := new(cgoAllocMap)
	allocs12bb4c74.Add(mem12bb4c74)

	var cdv_ind_allocs *cgoAllocMap
	ref12bb4c74.dv_ind, cdv_ind_allocs = (C.uint32_t)(x.dv_ind), cgoAllocsUnknown
	allocs12bb4c74.Borrow(cdv_ind_allocs)

	var cevent_allocs *cgoAllocMap
	ref12bb4c74.event, cevent_allocs = (C.rsmi_evt_notification_type_t)(x.event), cgoAllocsUnknown
	allocs12bb4c74.Borrow(cevent_allocs)

	var cmessage_allocs *cgoAllocMap
	ref12bb4c74.message, cmessage_allocs = *(*[64]C.char)(unsafe.Pointer(&x.message)), cgoAllocsUnknown
	allocs12bb4c74.Borrow(cmessage_allocs)

	x.ref12bb4c74 = ref12bb4c74
	x.allocs12bb4c74 = allocs12bb4c74
	return ref12bb4c74, allocs12bb4c74

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_evt_notification_data) PassValue() (C.rsmi_evt_notification_data_t, *cgoAllocMap) {
	if x.ref12bb4c74 != nil {
		return *x.ref12bb4c74, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_evt_notification_data) Deref() {
	if x.ref12bb4c74 == nil {
		return
	}
	x.dv_ind = (uint32)(x.ref12bb4c74.dv_ind)
	x.event = (rsmi_evt_notification_type)(x.ref12bb4c74.event)
	x.message = *(*[64]byte)(unsafe.Pointer(&x.ref12bb4c74.message))
}

// allocRsmi_utilization_counterMemory allocates memory for type C.rsmi_utilization_counter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_utilization_counterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_utilization_counterValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_utilization_counterValue = unsafe.Sizeof([1]C.rsmi_utilization_counter_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_utilization_counter) Ref() *C.rsmi_utilization_counter_t {
	if x == nil {
		return nil
	}
	return x.refe35e64e9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_utilization_counter) Free() {
	if x != nil && x.allocse35e64e9 != nil {
		x.allocse35e64e9.(*cgoAllocMap).Free()
		x.refe35e64e9 = nil
	}
}

// Newrsmi_utilization_counterRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_utilization_counterRef(ref unsafe.Pointer) *rsmi_utilization_counter {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_utilization_counter)
	obj.refe35e64e9 = (*C.rsmi_utilization_counter_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_utilization_counter) PassRef() (*C.rsmi_utilization_counter_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe35e64e9 != nil {
		return x.refe35e64e9, nil
	}
	meme35e64e9 := allocRsmi_utilization_counterMemory(1)
	refe35e64e9 := (*C.rsmi_utilization_counter_t)(meme35e64e9)
	allocse35e64e9 := new(cgoAllocMap)
	allocse35e64e9.Add(meme35e64e9)

	var c_type_allocs *cgoAllocMap
	refe35e64e9._type, c_type_allocs = (C.RSMI_UTILIZATION_COUNTER_TYPE)(x._type), cgoAllocsUnknown
	allocse35e64e9.Borrow(c_type_allocs)

	var cvalue_allocs *cgoAllocMap
	refe35e64e9.value, cvalue_allocs = (C.uint64_t)(x.value), cgoAllocsUnknown
	allocse35e64e9.Borrow(cvalue_allocs)

	x.refe35e64e9 = refe35e64e9
	x.allocse35e64e9 = allocse35e64e9
	return refe35e64e9, allocse35e64e9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_utilization_counter) PassValue() (C.rsmi_utilization_counter_t, *cgoAllocMap) {
	if x.refe35e64e9 != nil {
		return *x.refe35e64e9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_utilization_counter) Deref() {
	if x.refe35e64e9 == nil {
		return
	}
	x._type = (RSMI_UTILIZATION_COUNTER)(x.refe35e64e9._type)
	x.value = (uint64)(x.refe35e64e9.value)
}

// allocRsmi_retired_page_recordMemory allocates memory for type C.rsmi_retired_page_record_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_retired_page_recordMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_retired_page_recordValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_retired_page_recordValue = unsafe.Sizeof([1]C.rsmi_retired_page_record_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_retired_page_record) Ref() *C.rsmi_retired_page_record_t {
	if x == nil {
		return nil
	}
	return x.ref5cd74c7e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_retired_page_record) Free() {
	if x != nil && x.allocs5cd74c7e != nil {
		x.allocs5cd74c7e.(*cgoAllocMap).Free()
		x.ref5cd74c7e = nil
	}
}

// Newrsmi_retired_page_recordRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_retired_page_recordRef(ref unsafe.Pointer) *rsmi_retired_page_record {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_retired_page_record)
	obj.ref5cd74c7e = (*C.rsmi_retired_page_record_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_retired_page_record) PassRef() (*C.rsmi_retired_page_record_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5cd74c7e != nil {
		return x.ref5cd74c7e, nil
	}
	mem5cd74c7e := allocRsmi_retired_page_recordMemory(1)
	ref5cd74c7e := (*C.rsmi_retired_page_record_t)(mem5cd74c7e)
	allocs5cd74c7e := new(cgoAllocMap)
	allocs5cd74c7e.Add(mem5cd74c7e)

	var cpage_address_allocs *cgoAllocMap
	ref5cd74c7e.page_address, cpage_address_allocs = (C.uint64_t)(x.page_address), cgoAllocsUnknown
	allocs5cd74c7e.Borrow(cpage_address_allocs)

	var cpage_size_allocs *cgoAllocMap
	ref5cd74c7e.page_size, cpage_size_allocs = (C.uint64_t)(x.page_size), cgoAllocsUnknown
	allocs5cd74c7e.Borrow(cpage_size_allocs)

	var cstatus_allocs *cgoAllocMap
	ref5cd74c7e.status, cstatus_allocs = (C.rsmi_memory_page_status_t)(x.status), cgoAllocsUnknown
	allocs5cd74c7e.Borrow(cstatus_allocs)

	x.ref5cd74c7e = ref5cd74c7e
	x.allocs5cd74c7e = allocs5cd74c7e
	return ref5cd74c7e, allocs5cd74c7e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_retired_page_record) PassValue() (C.rsmi_retired_page_record_t, *cgoAllocMap) {
	if x.ref5cd74c7e != nil {
		return *x.ref5cd74c7e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_retired_page_record) Deref() {
	if x.ref5cd74c7e == nil {
		return
	}
	x.page_address = (uint64)(x.ref5cd74c7e.page_address)
	x.page_size = (uint64)(x.ref5cd74c7e.page_size)
	x.status = (rsmi_memory_page_status)(x.ref5cd74c7e.status)
}

// allocRsmi_power_profile_statusMemory allocates memory for type C.rsmi_power_profile_status_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_power_profile_statusMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_power_profile_statusValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_power_profile_statusValue = unsafe.Sizeof([1]C.rsmi_power_profile_status_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_power_profile_status) Ref() *C.rsmi_power_profile_status_t {
	if x == nil {
		return nil
	}
	return x.refead6fdb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_power_profile_status) Free() {
	if x != nil && x.allocsead6fdb != nil {
		x.allocsead6fdb.(*cgoAllocMap).Free()
		x.refead6fdb = nil
	}
}

// Newrsmi_power_profile_statusRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_power_profile_statusRef(ref unsafe.Pointer) *rsmi_power_profile_status {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_power_profile_status)
	obj.refead6fdb = (*C.rsmi_power_profile_status_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_power_profile_status) PassRef() (*C.rsmi_power_profile_status_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refead6fdb != nil {
		return x.refead6fdb, nil
	}
	memead6fdb := allocRsmi_power_profile_statusMemory(1)
	refead6fdb := (*C.rsmi_power_profile_status_t)(memead6fdb)
	allocsead6fdb := new(cgoAllocMap)
	allocsead6fdb.Add(memead6fdb)

	var cavailable_profiles_allocs *cgoAllocMap
	refead6fdb.available_profiles, cavailable_profiles_allocs = (C.rsmi_bit_field_t)(x.available_profiles), cgoAllocsUnknown
	allocsead6fdb.Borrow(cavailable_profiles_allocs)

	var ccurrent_allocs *cgoAllocMap
	refead6fdb.current, ccurrent_allocs = (C.rsmi_power_profile_preset_masks_t)(x.current), cgoAllocsUnknown
	allocsead6fdb.Borrow(ccurrent_allocs)

	var cnum_profiles_allocs *cgoAllocMap
	refead6fdb.num_profiles, cnum_profiles_allocs = (C.uint32_t)(x.num_profiles), cgoAllocsUnknown
	allocsead6fdb.Borrow(cnum_profiles_allocs)

	x.refead6fdb = refead6fdb
	x.allocsead6fdb = allocsead6fdb
	return refead6fdb, allocsead6fdb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_power_profile_status) PassValue() (C.rsmi_power_profile_status_t, *cgoAllocMap) {
	if x.refead6fdb != nil {
		return *x.refead6fdb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_power_profile_status) Deref() {
	if x.refead6fdb == nil {
		return
	}
	x.available_profiles = (rsmi_bit_field)(x.refead6fdb.available_profiles)
	x.current = (rsmi_power_profile_preset_masks)(x.refead6fdb.current)
	x.num_profiles = (uint32)(x.refead6fdb.num_profiles)
}

// allocRsmi_frequenciesMemory allocates memory for type C.rsmi_frequencies_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_frequenciesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_frequenciesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_frequenciesValue = unsafe.Sizeof([1]C.rsmi_frequencies_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_frequencies) Ref() *C.rsmi_frequencies_t {
	if x == nil {
		return nil
	}
	return x.ref64cedbcf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_frequencies) Free() {
	if x != nil && x.allocs64cedbcf != nil {
		x.allocs64cedbcf.(*cgoAllocMap).Free()
		x.ref64cedbcf = nil
	}
}

// Newrsmi_frequenciesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_frequenciesRef(ref unsafe.Pointer) *rsmi_frequencies {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_frequencies)
	obj.ref64cedbcf = (*C.rsmi_frequencies_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_frequencies) PassRef() (*C.rsmi_frequencies_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64cedbcf != nil {
		return x.ref64cedbcf, nil
	}
	mem64cedbcf := allocRsmi_frequenciesMemory(1)
	ref64cedbcf := (*C.rsmi_frequencies_t)(mem64cedbcf)
	allocs64cedbcf := new(cgoAllocMap)
	allocs64cedbcf.Add(mem64cedbcf)

	var chas_deep_sleep_allocs *cgoAllocMap
	ref64cedbcf.has_deep_sleep, chas_deep_sleep_allocs = (C._Bool)(x.has_deep_sleep), cgoAllocsUnknown
	allocs64cedbcf.Borrow(chas_deep_sleep_allocs)

	var cnum_supported_allocs *cgoAllocMap
	ref64cedbcf.num_supported, cnum_supported_allocs = (C.uint32_t)(x.num_supported), cgoAllocsUnknown
	allocs64cedbcf.Borrow(cnum_supported_allocs)

	var ccurrent_allocs *cgoAllocMap
	ref64cedbcf.current, ccurrent_allocs = (C.uint32_t)(x.current), cgoAllocsUnknown
	allocs64cedbcf.Borrow(ccurrent_allocs)

	var cfrequency_allocs *cgoAllocMap
	ref64cedbcf.frequency, cfrequency_allocs = *(*[33]C.uint64_t)(unsafe.Pointer(&x.frequency)), cgoAllocsUnknown
	allocs64cedbcf.Borrow(cfrequency_allocs)

	x.ref64cedbcf = ref64cedbcf
	x.allocs64cedbcf = allocs64cedbcf
	return ref64cedbcf, allocs64cedbcf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_frequencies) PassValue() (C.rsmi_frequencies_t, *cgoAllocMap) {
	if x.ref64cedbcf != nil {
		return *x.ref64cedbcf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_frequencies) Deref() {
	if x.ref64cedbcf == nil {
		return
	}
	x.has_deep_sleep = (bool)(x.ref64cedbcf.has_deep_sleep)
	x.num_supported = (uint32)(x.ref64cedbcf.num_supported)
	x.current = (uint32)(x.ref64cedbcf.current)
	x.frequency = *(*[33]uint64)(unsafe.Pointer(&x.ref64cedbcf.frequency))
}

// allocRsmi_pcie_bandwidthMemory allocates memory for type C.rsmi_pcie_bandwidth_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_pcie_bandwidthMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_pcie_bandwidthValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_pcie_bandwidthValue = unsafe.Sizeof([1]C.rsmi_pcie_bandwidth_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_pcie_bandwidth) Ref() *C.rsmi_pcie_bandwidth_t {
	if x == nil {
		return nil
	}
	return x.ref85c8716e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_pcie_bandwidth) Free() {
	if x != nil && x.allocs85c8716e != nil {
		x.allocs85c8716e.(*cgoAllocMap).Free()
		x.ref85c8716e = nil
	}
}

// Newrsmi_pcie_bandwidthRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_pcie_bandwidthRef(ref unsafe.Pointer) *rsmi_pcie_bandwidth {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_pcie_bandwidth)
	obj.ref85c8716e = (*C.rsmi_pcie_bandwidth_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_pcie_bandwidth) PassRef() (*C.rsmi_pcie_bandwidth_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85c8716e != nil {
		return x.ref85c8716e, nil
	}
	mem85c8716e := allocRsmi_pcie_bandwidthMemory(1)
	ref85c8716e := (*C.rsmi_pcie_bandwidth_t)(mem85c8716e)
	allocs85c8716e := new(cgoAllocMap)
	allocs85c8716e.Add(mem85c8716e)

	var ctransfer_rate_allocs *cgoAllocMap
	ref85c8716e.transfer_rate, ctransfer_rate_allocs = x.transfer_rate.PassValue()
	allocs85c8716e.Borrow(ctransfer_rate_allocs)

	var clanes_allocs *cgoAllocMap
	ref85c8716e.lanes, clanes_allocs = *(*[33]C.uint32_t)(unsafe.Pointer(&x.lanes)), cgoAllocsUnknown
	allocs85c8716e.Borrow(clanes_allocs)

	x.ref85c8716e = ref85c8716e
	x.allocs85c8716e = allocs85c8716e
	return ref85c8716e, allocs85c8716e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_pcie_bandwidth) PassValue() (C.rsmi_pcie_bandwidth_t, *cgoAllocMap) {
	if x.ref85c8716e != nil {
		return *x.ref85c8716e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_pcie_bandwidth) Deref() {
	if x.ref85c8716e == nil {
		return
	}
	x.transfer_rate = *Newrsmi_frequenciesRef(unsafe.Pointer(&x.ref85c8716e.transfer_rate))
	x.lanes = *(*[33]uint32)(unsafe.Pointer(&x.ref85c8716e.lanes))
}

// allocRsmi_activity_metric_counterMemory allocates memory for type C.rsmi_activity_metric_counter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_activity_metric_counterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_activity_metric_counterValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_activity_metric_counterValue = unsafe.Sizeof([1]C.rsmi_activity_metric_counter_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_activity_metric_counter) Ref() *C.rsmi_activity_metric_counter_t {
	if x == nil {
		return nil
	}
	return x.ref12a9585f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_activity_metric_counter) Free() {
	if x != nil && x.allocs12a9585f != nil {
		x.allocs12a9585f.(*cgoAllocMap).Free()
		x.ref12a9585f = nil
	}
}

// Newrsmi_activity_metric_counterRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_activity_metric_counterRef(ref unsafe.Pointer) *rsmi_activity_metric_counter {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_activity_metric_counter)
	obj.ref12a9585f = (*C.rsmi_activity_metric_counter_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_activity_metric_counter) PassRef() (*C.rsmi_activity_metric_counter_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12a9585f != nil {
		return x.ref12a9585f, nil
	}
	mem12a9585f := allocRsmi_activity_metric_counterMemory(1)
	ref12a9585f := (*C.rsmi_activity_metric_counter_t)(mem12a9585f)
	allocs12a9585f := new(cgoAllocMap)
	allocs12a9585f.Add(mem12a9585f)

	var caverage_gfx_activity_allocs *cgoAllocMap
	ref12a9585f.average_gfx_activity, caverage_gfx_activity_allocs = (C.uint16_t)(x.average_gfx_activity), cgoAllocsUnknown
	allocs12a9585f.Borrow(caverage_gfx_activity_allocs)

	var caverage_umc_activity_allocs *cgoAllocMap
	ref12a9585f.average_umc_activity, caverage_umc_activity_allocs = (C.uint16_t)(x.average_umc_activity), cgoAllocsUnknown
	allocs12a9585f.Borrow(caverage_umc_activity_allocs)

	var caverage_mm_activity_allocs *cgoAllocMap
	ref12a9585f.average_mm_activity, caverage_mm_activity_allocs = (C.uint16_t)(x.average_mm_activity), cgoAllocsUnknown
	allocs12a9585f.Borrow(caverage_mm_activity_allocs)

	x.ref12a9585f = ref12a9585f
	x.allocs12a9585f = allocs12a9585f
	return ref12a9585f, allocs12a9585f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_activity_metric_counter) PassValue() (C.rsmi_activity_metric_counter_t, *cgoAllocMap) {
	if x.ref12a9585f != nil {
		return *x.ref12a9585f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_activity_metric_counter) Deref() {
	if x.ref12a9585f == nil {
		return
	}
	x.average_gfx_activity = (uint16)(x.ref12a9585f.average_gfx_activity)
	x.average_umc_activity = (uint16)(x.ref12a9585f.average_umc_activity)
	x.average_mm_activity = (uint16)(x.ref12a9585f.average_mm_activity)
}

// allocRsmi_versionMemory allocates memory for type C.rsmi_version_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_versionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_versionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_versionValue = unsafe.Sizeof([1]C.rsmi_version_t{})

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_version) Ref() *C.rsmi_version_t {
	if x == nil {
		return nil
	}
	return x.ref3a694ceb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_version) Free() {
	if x != nil && x.allocs3a694ceb != nil {
		x.allocs3a694ceb.(*cgoAllocMap).Free()
		x.ref3a694ceb = nil
	}
}

// Newrsmi_versionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_versionRef(ref unsafe.Pointer) *rsmi_version {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_version)
	obj.ref3a694ceb = (*C.rsmi_version_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_version) PassRef() (*C.rsmi_version_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3a694ceb != nil {
		return x.ref3a694ceb, nil
	}
	mem3a694ceb := allocRsmi_versionMemory(1)
	ref3a694ceb := (*C.rsmi_version_t)(mem3a694ceb)
	allocs3a694ceb := new(cgoAllocMap)
	allocs3a694ceb.Add(mem3a694ceb)

	var cmajor_allocs *cgoAllocMap
	ref3a694ceb.major, cmajor_allocs = (C.uint32_t)(x.major), cgoAllocsUnknown
	allocs3a694ceb.Borrow(cmajor_allocs)

	var cminor_allocs *cgoAllocMap
	ref3a694ceb.minor, cminor_allocs = (C.uint32_t)(x.minor), cgoAllocsUnknown
	allocs3a694ceb.Borrow(cminor_allocs)

	var cpatch_allocs *cgoAllocMap
	ref3a694ceb.patch, cpatch_allocs = (C.uint32_t)(x.patch), cgoAllocsUnknown
	allocs3a694ceb.Borrow(cpatch_allocs)

	var cbuild_allocs *cgoAllocMap
	ref3a694ceb.build, cbuild_allocs = unpackPCharString(x.build)
	allocs3a694ceb.Borrow(cbuild_allocs)

	x.ref3a694ceb = ref3a694ceb
	x.allocs3a694ceb = allocs3a694ceb
	return ref3a694ceb, allocs3a694ceb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_version) PassValue() (C.rsmi_version_t, *cgoAllocMap) {
	if x.ref3a694ceb != nil {
		return *x.ref3a694ceb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_version) Deref() {
	if x.ref3a694ceb == nil {
		return
	}
	x.major = (uint32)(x.ref3a694ceb.major)
	x.minor = (uint32)(x.ref3a694ceb.minor)
	x.patch = (uint32)(x.ref3a694ceb.patch)
	x.build = packPCharString(x.ref3a694ceb.build)
}

// allocRsmi_rangeMemory allocates memory for type C.rsmi_range_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_rangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_rangeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_rangeValue = unsafe.Sizeof([1]C.rsmi_range_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_range) Ref() *C.rsmi_range_t {
	if x == nil {
		return nil
	}
	return x.ref904052bd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_range) Free() {
	if x != nil && x.allocs904052bd != nil {
		x.allocs904052bd.(*cgoAllocMap).Free()
		x.ref904052bd = nil
	}
}

// Newrsmi_rangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_rangeRef(ref unsafe.Pointer) *rsmi_range {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_range)
	obj.ref904052bd = (*C.rsmi_range_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_range) PassRef() (*C.rsmi_range_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref904052bd != nil {
		return x.ref904052bd, nil
	}
	mem904052bd := allocRsmi_rangeMemory(1)
	ref904052bd := (*C.rsmi_range_t)(mem904052bd)
	allocs904052bd := new(cgoAllocMap)
	allocs904052bd.Add(mem904052bd)

	var clower_bound_allocs *cgoAllocMap
	ref904052bd.lower_bound, clower_bound_allocs = (C.uint64_t)(x.lower_bound), cgoAllocsUnknown
	allocs904052bd.Borrow(clower_bound_allocs)

	var cupper_bound_allocs *cgoAllocMap
	ref904052bd.upper_bound, cupper_bound_allocs = (C.uint64_t)(x.upper_bound), cgoAllocsUnknown
	allocs904052bd.Borrow(cupper_bound_allocs)

	x.ref904052bd = ref904052bd
	x.allocs904052bd = allocs904052bd
	return ref904052bd, allocs904052bd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_range) PassValue() (C.rsmi_range_t, *cgoAllocMap) {
	if x.ref904052bd != nil {
		return *x.ref904052bd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_range) Deref() {
	if x.ref904052bd == nil {
		return
	}
	x.lower_bound = (uint64)(x.ref904052bd.lower_bound)
	x.upper_bound = (uint64)(x.ref904052bd.upper_bound)
}

// allocRsmi_od_vddc_pointMemory allocates memory for type C.rsmi_od_vddc_point_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_od_vddc_pointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_od_vddc_pointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_od_vddc_pointValue = unsafe.Sizeof([1]C.rsmi_od_vddc_point_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_od_vddc_point) Ref() *C.rsmi_od_vddc_point_t {
	if x == nil {
		return nil
	}
	return x.ref45c07bad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_od_vddc_point) Free() {
	if x != nil && x.allocs45c07bad != nil {
		x.allocs45c07bad.(*cgoAllocMap).Free()
		x.ref45c07bad = nil
	}
}

// Newrsmi_od_vddc_pointRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_od_vddc_pointRef(ref unsafe.Pointer) *rsmi_od_vddc_point {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_od_vddc_point)
	obj.ref45c07bad = (*C.rsmi_od_vddc_point_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_od_vddc_point) PassRef() (*C.rsmi_od_vddc_point_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref45c07bad != nil {
		return x.ref45c07bad, nil
	}
	mem45c07bad := allocRsmi_od_vddc_pointMemory(1)
	ref45c07bad := (*C.rsmi_od_vddc_point_t)(mem45c07bad)
	allocs45c07bad := new(cgoAllocMap)
	allocs45c07bad.Add(mem45c07bad)

	var cfrequency_allocs *cgoAllocMap
	ref45c07bad.frequency, cfrequency_allocs = (C.uint64_t)(x.frequency), cgoAllocsUnknown
	allocs45c07bad.Borrow(cfrequency_allocs)

	var cvoltage_allocs *cgoAllocMap
	ref45c07bad.voltage, cvoltage_allocs = (C.uint64_t)(x.voltage), cgoAllocsUnknown
	allocs45c07bad.Borrow(cvoltage_allocs)

	x.ref45c07bad = ref45c07bad
	x.allocs45c07bad = allocs45c07bad
	return ref45c07bad, allocs45c07bad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_od_vddc_point) PassValue() (C.rsmi_od_vddc_point_t, *cgoAllocMap) {
	if x.ref45c07bad != nil {
		return *x.ref45c07bad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_od_vddc_point) Deref() {
	if x.ref45c07bad == nil {
		return
	}
	x.frequency = (uint64)(x.ref45c07bad.frequency)
	x.voltage = (uint64)(x.ref45c07bad.voltage)
}

// allocRsmi_freq_volt_regionMemory allocates memory for type C.rsmi_freq_volt_region_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_freq_volt_regionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_freq_volt_regionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_freq_volt_regionValue = unsafe.Sizeof([1]C.rsmi_freq_volt_region_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_freq_volt_region) Ref() *C.rsmi_freq_volt_region_t {
	if x == nil {
		return nil
	}
	return x.ref2b8059c6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_freq_volt_region) Free() {
	if x != nil && x.allocs2b8059c6 != nil {
		x.allocs2b8059c6.(*cgoAllocMap).Free()
		x.ref2b8059c6 = nil
	}
}

// Newrsmi_freq_volt_regionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_freq_volt_regionRef(ref unsafe.Pointer) *rsmi_freq_volt_region {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_freq_volt_region)
	obj.ref2b8059c6 = (*C.rsmi_freq_volt_region_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_freq_volt_region) PassRef() (*C.rsmi_freq_volt_region_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b8059c6 != nil {
		return x.ref2b8059c6, nil
	}
	mem2b8059c6 := allocRsmi_freq_volt_regionMemory(1)
	ref2b8059c6 := (*C.rsmi_freq_volt_region_t)(mem2b8059c6)
	allocs2b8059c6 := new(cgoAllocMap)
	allocs2b8059c6.Add(mem2b8059c6)

	var cfreq_range_allocs *cgoAllocMap
	ref2b8059c6.freq_range, cfreq_range_allocs = x.freq_range.PassValue()
	allocs2b8059c6.Borrow(cfreq_range_allocs)

	var cvolt_range_allocs *cgoAllocMap
	ref2b8059c6.volt_range, cvolt_range_allocs = x.volt_range.PassValue()
	allocs2b8059c6.Borrow(cvolt_range_allocs)

	x.ref2b8059c6 = ref2b8059c6
	x.allocs2b8059c6 = allocs2b8059c6
	return ref2b8059c6, allocs2b8059c6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_freq_volt_region) PassValue() (C.rsmi_freq_volt_region_t, *cgoAllocMap) {
	if x.ref2b8059c6 != nil {
		return *x.ref2b8059c6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_freq_volt_region) Deref() {
	if x.ref2b8059c6 == nil {
		return
	}
	x.freq_range = *Newrsmi_rangeRef(unsafe.Pointer(&x.ref2b8059c6.freq_range))
	x.volt_range = *Newrsmi_rangeRef(unsafe.Pointer(&x.ref2b8059c6.volt_range))
}

// allocRsmi_od_volt_curveMemory allocates memory for type C.rsmi_od_volt_curve_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_od_volt_curveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_od_volt_curveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_od_volt_curveValue = unsafe.Sizeof([1]C.rsmi_od_volt_curve_t{})

// allocA3Rsmi_od_vddc_pointMemory allocates memory for type [3]C.rsmi_od_vddc_point_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA3Rsmi_od_vddc_pointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA3Rsmi_od_vddc_pointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA3Rsmi_od_vddc_pointValue = unsafe.Sizeof([1][3]C.rsmi_od_vddc_point_t{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA3Rsmi_od_vddc_point transforms a sliced Go data structure into plain C format.
func unpackA3Rsmi_od_vddc_point(x [3]rsmi_od_vddc_point) (unpacked [3]C.rsmi_od_vddc_point_t, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA3Rsmi_od_vddc_pointMemory(1)
	allocs.Add(mem0)
	v0 := (*[3]C.rsmi_od_vddc_point_t)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[3]C.rsmi_od_vddc_point_t)(mem0)
	return
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// packA3Rsmi_od_vddc_point reads sliced Go data structure out from plain C format.
func packA3Rsmi_od_vddc_point(v *[3]rsmi_od_vddc_point, ptr0 *[3]C.rsmi_od_vddc_point_t) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *Newrsmi_od_vddc_pointRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_od_volt_curve) Ref() *C.rsmi_od_volt_curve_t {
	if x == nil {
		return nil
	}
	return x.refd69524af
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_od_volt_curve) Free() {
	if x != nil && x.allocsd69524af != nil {
		x.allocsd69524af.(*cgoAllocMap).Free()
		x.refd69524af = nil
	}
}

// Newrsmi_od_volt_curveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_od_volt_curveRef(ref unsafe.Pointer) *rsmi_od_volt_curve {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_od_volt_curve)
	obj.refd69524af = (*C.rsmi_od_volt_curve_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_od_volt_curve) PassRef() (*C.rsmi_od_volt_curve_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd69524af != nil {
		return x.refd69524af, nil
	}
	memd69524af := allocRsmi_od_volt_curveMemory(1)
	refd69524af := (*C.rsmi_od_volt_curve_t)(memd69524af)
	allocsd69524af := new(cgoAllocMap)
	allocsd69524af.Add(memd69524af)

	var cvc_points_allocs *cgoAllocMap
	refd69524af.vc_points, cvc_points_allocs = unpackA3Rsmi_od_vddc_point(x.vc_points)
	allocsd69524af.Borrow(cvc_points_allocs)

	x.refd69524af = refd69524af
	x.allocsd69524af = allocsd69524af
	return refd69524af, allocsd69524af

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_od_volt_curve) PassValue() (C.rsmi_od_volt_curve_t, *cgoAllocMap) {
	if x.refd69524af != nil {
		return *x.refd69524af, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_od_volt_curve) Deref() {
	if x.refd69524af == nil {
		return
	}
	packA3Rsmi_od_vddc_point(&x.vc_points, (*[3]C.rsmi_od_vddc_point_t)(unsafe.Pointer(&x.refd69524af.vc_points)))
}

// allocRsmi_od_volt_freq_dataMemory allocates memory for type C.rsmi_od_volt_freq_data_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_od_volt_freq_dataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_od_volt_freq_dataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_od_volt_freq_dataValue = unsafe.Sizeof([1]C.rsmi_od_volt_freq_data_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_od_volt_freq_data) Ref() *C.rsmi_od_volt_freq_data_t {
	if x == nil {
		return nil
	}
	return x.ref34ccd7b5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_od_volt_freq_data) Free() {
	if x != nil && x.allocs34ccd7b5 != nil {
		x.allocs34ccd7b5.(*cgoAllocMap).Free()
		x.ref34ccd7b5 = nil
	}
}

// Newrsmi_od_volt_freq_dataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_od_volt_freq_dataRef(ref unsafe.Pointer) *rsmi_od_volt_freq_data {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_od_volt_freq_data)
	obj.ref34ccd7b5 = (*C.rsmi_od_volt_freq_data_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_od_volt_freq_data) PassRef() (*C.rsmi_od_volt_freq_data_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34ccd7b5 != nil {
		return x.ref34ccd7b5, nil
	}
	mem34ccd7b5 := allocRsmi_od_volt_freq_dataMemory(1)
	ref34ccd7b5 := (*C.rsmi_od_volt_freq_data_t)(mem34ccd7b5)
	allocs34ccd7b5 := new(cgoAllocMap)
	allocs34ccd7b5.Add(mem34ccd7b5)

	var ccurr_sclk_range_allocs *cgoAllocMap
	ref34ccd7b5.curr_sclk_range, ccurr_sclk_range_allocs = x.curr_sclk_range.PassValue()
	allocs34ccd7b5.Borrow(ccurr_sclk_range_allocs)

	var ccurr_mclk_range_allocs *cgoAllocMap
	ref34ccd7b5.curr_mclk_range, ccurr_mclk_range_allocs = x.curr_mclk_range.PassValue()
	allocs34ccd7b5.Borrow(ccurr_mclk_range_allocs)

	var csclk_freq_limits_allocs *cgoAllocMap
	ref34ccd7b5.sclk_freq_limits, csclk_freq_limits_allocs = x.sclk_freq_limits.PassValue()
	allocs34ccd7b5.Borrow(csclk_freq_limits_allocs)

	var cmclk_freq_limits_allocs *cgoAllocMap
	ref34ccd7b5.mclk_freq_limits, cmclk_freq_limits_allocs = x.mclk_freq_limits.PassValue()
	allocs34ccd7b5.Borrow(cmclk_freq_limits_allocs)

	var ccurve_allocs *cgoAllocMap
	ref34ccd7b5.curve, ccurve_allocs = x.curve.PassValue()
	allocs34ccd7b5.Borrow(ccurve_allocs)

	var cnum_regions_allocs *cgoAllocMap
	ref34ccd7b5.num_regions, cnum_regions_allocs = (C.uint32_t)(x.num_regions), cgoAllocsUnknown
	allocs34ccd7b5.Borrow(cnum_regions_allocs)

	x.ref34ccd7b5 = ref34ccd7b5
	x.allocs34ccd7b5 = allocs34ccd7b5
	return ref34ccd7b5, allocs34ccd7b5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_od_volt_freq_data) PassValue() (C.rsmi_od_volt_freq_data_t, *cgoAllocMap) {
	if x.ref34ccd7b5 != nil {
		return *x.ref34ccd7b5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_od_volt_freq_data) Deref() {
	if x.ref34ccd7b5 == nil {
		return
	}
	x.curr_sclk_range = *Newrsmi_rangeRef(unsafe.Pointer(&x.ref34ccd7b5.curr_sclk_range))
	x.curr_mclk_range = *Newrsmi_rangeRef(unsafe.Pointer(&x.ref34ccd7b5.curr_mclk_range))
	x.sclk_freq_limits = *Newrsmi_rangeRef(unsafe.Pointer(&x.ref34ccd7b5.sclk_freq_limits))
	x.mclk_freq_limits = *Newrsmi_rangeRef(unsafe.Pointer(&x.ref34ccd7b5.mclk_freq_limits))
	x.curve = *Newrsmi_od_volt_curveRef(unsafe.Pointer(&x.ref34ccd7b5.curve))
	x.num_regions = (uint32)(x.ref34ccd7b5.num_regions)
}

// allocMetrics_table_headerMemory allocates memory for type C.metrics_table_header_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMetrics_table_headerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMetrics_table_headerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMetrics_table_headerValue = unsafe.Sizeof([1]C.metrics_table_header_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *metrics_table_header) Ref() *C.metrics_table_header_t {
	if x == nil {
		return nil
	}
	return x.ref81dc70c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *metrics_table_header) Free() {
	if x != nil && x.allocs81dc70c != nil {
		x.allocs81dc70c.(*cgoAllocMap).Free()
		x.ref81dc70c = nil
	}
}

// Newmetrics_table_headerRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newmetrics_table_headerRef(ref unsafe.Pointer) *metrics_table_header {
	if ref == nil {
		return nil
	}
	obj := new(metrics_table_header)
	obj.ref81dc70c = (*C.metrics_table_header_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *metrics_table_header) PassRef() (*C.metrics_table_header_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref81dc70c != nil {
		return x.ref81dc70c, nil
	}
	mem81dc70c := allocMetrics_table_headerMemory(1)
	ref81dc70c := (*C.metrics_table_header_t)(mem81dc70c)
	allocs81dc70c := new(cgoAllocMap)
	allocs81dc70c.Add(mem81dc70c)

	var cstructure_size_allocs *cgoAllocMap
	ref81dc70c.structure_size, cstructure_size_allocs = (C.uint16_t)(x.structure_size), cgoAllocsUnknown
	allocs81dc70c.Borrow(cstructure_size_allocs)

	var cformat_revision_allocs *cgoAllocMap
	ref81dc70c.format_revision, cformat_revision_allocs = (C.uint8_t)(x.format_revision), cgoAllocsUnknown
	allocs81dc70c.Borrow(cformat_revision_allocs)

	var ccontent_revision_allocs *cgoAllocMap
	ref81dc70c.content_revision, ccontent_revision_allocs = (C.uint8_t)(x.content_revision), cgoAllocsUnknown
	allocs81dc70c.Borrow(ccontent_revision_allocs)

	x.ref81dc70c = ref81dc70c
	x.allocs81dc70c = allocs81dc70c
	return ref81dc70c, allocs81dc70c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x metrics_table_header) PassValue() (C.metrics_table_header_t, *cgoAllocMap) {
	if x.ref81dc70c != nil {
		return *x.ref81dc70c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *metrics_table_header) Deref() {
	if x.ref81dc70c == nil {
		return
	}
	x.structure_size = (uint16)(x.ref81dc70c.structure_size)
	x.format_revision = (byte)(x.ref81dc70c.format_revision)
	x.content_revision = (byte)(x.ref81dc70c.content_revision)
}

// allocRsmi_gpu_metricsMemory allocates memory for type C.rsmi_gpu_metrics_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_gpu_metricsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_gpu_metricsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_gpu_metricsValue = unsafe.Sizeof([1]C.rsmi_gpu_metrics_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_gpu_metrics) Ref() *C.rsmi_gpu_metrics_t {
	if x == nil {
		return nil
	}
	return x.ref9356c676
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_gpu_metrics) Free() {
	if x != nil && x.allocs9356c676 != nil {
		x.allocs9356c676.(*cgoAllocMap).Free()
		x.ref9356c676 = nil
	}
}

// Newrsmi_gpu_metricsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_gpu_metricsRef(ref unsafe.Pointer) *rsmi_gpu_metrics {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_gpu_metrics)
	obj.ref9356c676 = (*C.rsmi_gpu_metrics_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_gpu_metrics) PassRef() (*C.rsmi_gpu_metrics_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9356c676 != nil {
		return x.ref9356c676, nil
	}
	mem9356c676 := allocRsmi_gpu_metricsMemory(1)
	ref9356c676 := (*C.rsmi_gpu_metrics_t)(mem9356c676)
	allocs9356c676 := new(cgoAllocMap)
	allocs9356c676.Add(mem9356c676)

	var ccommon_header_allocs *cgoAllocMap
	ref9356c676.common_header, ccommon_header_allocs = x.common_header.PassValue()
	allocs9356c676.Borrow(ccommon_header_allocs)

	var ctemperature_edge_allocs *cgoAllocMap
	ref9356c676.temperature_edge, ctemperature_edge_allocs = (C.uint16_t)(x.temperature_edge), cgoAllocsUnknown
	allocs9356c676.Borrow(ctemperature_edge_allocs)

	var ctemperature_hotspot_allocs *cgoAllocMap
	ref9356c676.temperature_hotspot, ctemperature_hotspot_allocs = (C.uint16_t)(x.temperature_hotspot), cgoAllocsUnknown
	allocs9356c676.Borrow(ctemperature_hotspot_allocs)

	var ctemperature_mem_allocs *cgoAllocMap
	ref9356c676.temperature_mem, ctemperature_mem_allocs = (C.uint16_t)(x.temperature_mem), cgoAllocsUnknown
	allocs9356c676.Borrow(ctemperature_mem_allocs)

	var ctemperature_vrgfx_allocs *cgoAllocMap
	ref9356c676.temperature_vrgfx, ctemperature_vrgfx_allocs = (C.uint16_t)(x.temperature_vrgfx), cgoAllocsUnknown
	allocs9356c676.Borrow(ctemperature_vrgfx_allocs)

	var ctemperature_vrsoc_allocs *cgoAllocMap
	ref9356c676.temperature_vrsoc, ctemperature_vrsoc_allocs = (C.uint16_t)(x.temperature_vrsoc), cgoAllocsUnknown
	allocs9356c676.Borrow(ctemperature_vrsoc_allocs)

	var ctemperature_vrmem_allocs *cgoAllocMap
	ref9356c676.temperature_vrmem, ctemperature_vrmem_allocs = (C.uint16_t)(x.temperature_vrmem), cgoAllocsUnknown
	allocs9356c676.Borrow(ctemperature_vrmem_allocs)

	var caverage_gfx_activity_allocs *cgoAllocMap
	ref9356c676.average_gfx_activity, caverage_gfx_activity_allocs = (C.uint16_t)(x.average_gfx_activity), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_gfx_activity_allocs)

	var caverage_umc_activity_allocs *cgoAllocMap
	ref9356c676.average_umc_activity, caverage_umc_activity_allocs = (C.uint16_t)(x.average_umc_activity), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_umc_activity_allocs)

	var caverage_mm_activity_allocs *cgoAllocMap
	ref9356c676.average_mm_activity, caverage_mm_activity_allocs = (C.uint16_t)(x.average_mm_activity), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_mm_activity_allocs)

	var caverage_socket_power_allocs *cgoAllocMap
	ref9356c676.average_socket_power, caverage_socket_power_allocs = (C.uint16_t)(x.average_socket_power), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_socket_power_allocs)

	var cenergy_accumulator_allocs *cgoAllocMap
	ref9356c676.energy_accumulator, cenergy_accumulator_allocs = (C.uint64_t)(x.energy_accumulator), cgoAllocsUnknown
	allocs9356c676.Borrow(cenergy_accumulator_allocs)

	var csystem_clock_counter_allocs *cgoAllocMap
	ref9356c676.system_clock_counter, csystem_clock_counter_allocs = (C.uint64_t)(x.system_clock_counter), cgoAllocsUnknown
	allocs9356c676.Borrow(csystem_clock_counter_allocs)

	var caverage_gfxclk_frequency_allocs *cgoAllocMap
	ref9356c676.average_gfxclk_frequency, caverage_gfxclk_frequency_allocs = (C.uint16_t)(x.average_gfxclk_frequency), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_gfxclk_frequency_allocs)

	var caverage_socclk_frequency_allocs *cgoAllocMap
	ref9356c676.average_socclk_frequency, caverage_socclk_frequency_allocs = (C.uint16_t)(x.average_socclk_frequency), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_socclk_frequency_allocs)

	var caverage_uclk_frequency_allocs *cgoAllocMap
	ref9356c676.average_uclk_frequency, caverage_uclk_frequency_allocs = (C.uint16_t)(x.average_uclk_frequency), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_uclk_frequency_allocs)

	var caverage_vclk0_frequency_allocs *cgoAllocMap
	ref9356c676.average_vclk0_frequency, caverage_vclk0_frequency_allocs = (C.uint16_t)(x.average_vclk0_frequency), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_vclk0_frequency_allocs)

	var caverage_dclk0_frequency_allocs *cgoAllocMap
	ref9356c676.average_dclk0_frequency, caverage_dclk0_frequency_allocs = (C.uint16_t)(x.average_dclk0_frequency), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_dclk0_frequency_allocs)

	var caverage_vclk1_frequency_allocs *cgoAllocMap
	ref9356c676.average_vclk1_frequency, caverage_vclk1_frequency_allocs = (C.uint16_t)(x.average_vclk1_frequency), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_vclk1_frequency_allocs)

	var caverage_dclk1_frequency_allocs *cgoAllocMap
	ref9356c676.average_dclk1_frequency, caverage_dclk1_frequency_allocs = (C.uint16_t)(x.average_dclk1_frequency), cgoAllocsUnknown
	allocs9356c676.Borrow(caverage_dclk1_frequency_allocs)

	var ccurrent_gfxclk_allocs *cgoAllocMap
	ref9356c676.current_gfxclk, ccurrent_gfxclk_allocs = (C.uint16_t)(x.current_gfxclk), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_gfxclk_allocs)

	var ccurrent_socclk_allocs *cgoAllocMap
	ref9356c676.current_socclk, ccurrent_socclk_allocs = (C.uint16_t)(x.current_socclk), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_socclk_allocs)

	var ccurrent_uclk_allocs *cgoAllocMap
	ref9356c676.current_uclk, ccurrent_uclk_allocs = (C.uint16_t)(x.current_uclk), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_uclk_allocs)

	var ccurrent_vclk0_allocs *cgoAllocMap
	ref9356c676.current_vclk0, ccurrent_vclk0_allocs = (C.uint16_t)(x.current_vclk0), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_vclk0_allocs)

	var ccurrent_dclk0_allocs *cgoAllocMap
	ref9356c676.current_dclk0, ccurrent_dclk0_allocs = (C.uint16_t)(x.current_dclk0), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_dclk0_allocs)

	var ccurrent_vclk1_allocs *cgoAllocMap
	ref9356c676.current_vclk1, ccurrent_vclk1_allocs = (C.uint16_t)(x.current_vclk1), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_vclk1_allocs)

	var ccurrent_dclk1_allocs *cgoAllocMap
	ref9356c676.current_dclk1, ccurrent_dclk1_allocs = (C.uint16_t)(x.current_dclk1), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_dclk1_allocs)

	var cthrottle_status_allocs *cgoAllocMap
	ref9356c676.throttle_status, cthrottle_status_allocs = (C.uint32_t)(x.throttle_status), cgoAllocsUnknown
	allocs9356c676.Borrow(cthrottle_status_allocs)

	var ccurrent_fan_speed_allocs *cgoAllocMap
	ref9356c676.current_fan_speed, ccurrent_fan_speed_allocs = (C.uint16_t)(x.current_fan_speed), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_fan_speed_allocs)

	var cpcie_link_width_allocs *cgoAllocMap
	ref9356c676.pcie_link_width, cpcie_link_width_allocs = (C.uint16_t)(x.pcie_link_width), cgoAllocsUnknown
	allocs9356c676.Borrow(cpcie_link_width_allocs)

	var cpcie_link_speed_allocs *cgoAllocMap
	ref9356c676.pcie_link_speed, cpcie_link_speed_allocs = (C.uint16_t)(x.pcie_link_speed), cgoAllocsUnknown
	allocs9356c676.Borrow(cpcie_link_speed_allocs)

	var cgfx_activity_acc_allocs *cgoAllocMap
	ref9356c676.gfx_activity_acc, cgfx_activity_acc_allocs = (C.uint32_t)(x.gfx_activity_acc), cgoAllocsUnknown
	allocs9356c676.Borrow(cgfx_activity_acc_allocs)

	var cmem_activity_acc_allocs *cgoAllocMap
	ref9356c676.mem_activity_acc, cmem_activity_acc_allocs = (C.uint32_t)(x.mem_activity_acc), cgoAllocsUnknown
	allocs9356c676.Borrow(cmem_activity_acc_allocs)

	var ctemperature_hbm_allocs *cgoAllocMap
	ref9356c676.temperature_hbm, ctemperature_hbm_allocs = *(*[4]C.uint16_t)(unsafe.Pointer(&x.temperature_hbm)), cgoAllocsUnknown
	allocs9356c676.Borrow(ctemperature_hbm_allocs)

	var cfirmware_timestamp_allocs *cgoAllocMap
	ref9356c676.firmware_timestamp, cfirmware_timestamp_allocs = (C.uint64_t)(x.firmware_timestamp), cgoAllocsUnknown
	allocs9356c676.Borrow(cfirmware_timestamp_allocs)

	var cvoltage_soc_allocs *cgoAllocMap
	ref9356c676.voltage_soc, cvoltage_soc_allocs = (C.uint16_t)(x.voltage_soc), cgoAllocsUnknown
	allocs9356c676.Borrow(cvoltage_soc_allocs)

	var cvoltage_gfx_allocs *cgoAllocMap
	ref9356c676.voltage_gfx, cvoltage_gfx_allocs = (C.uint16_t)(x.voltage_gfx), cgoAllocsUnknown
	allocs9356c676.Borrow(cvoltage_gfx_allocs)

	var cvoltage_mem_allocs *cgoAllocMap
	ref9356c676.voltage_mem, cvoltage_mem_allocs = (C.uint16_t)(x.voltage_mem), cgoAllocsUnknown
	allocs9356c676.Borrow(cvoltage_mem_allocs)

	var cindep_throttle_status_allocs *cgoAllocMap
	ref9356c676.indep_throttle_status, cindep_throttle_status_allocs = (C.uint64_t)(x.indep_throttle_status), cgoAllocsUnknown
	allocs9356c676.Borrow(cindep_throttle_status_allocs)

	var ccurrent_socket_power_allocs *cgoAllocMap
	ref9356c676.current_socket_power, ccurrent_socket_power_allocs = (C.uint16_t)(x.current_socket_power), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_socket_power_allocs)

	var cvcn_activity_allocs *cgoAllocMap
	ref9356c676.vcn_activity, cvcn_activity_allocs = *(*[4]C.uint16_t)(unsafe.Pointer(&x.vcn_activity)), cgoAllocsUnknown
	allocs9356c676.Borrow(cvcn_activity_allocs)

	var cgfxclk_lock_status_allocs *cgoAllocMap
	ref9356c676.gfxclk_lock_status, cgfxclk_lock_status_allocs = (C.uint32_t)(x.gfxclk_lock_status), cgoAllocsUnknown
	allocs9356c676.Borrow(cgfxclk_lock_status_allocs)

	var cxgmi_link_width_allocs *cgoAllocMap
	ref9356c676.xgmi_link_width, cxgmi_link_width_allocs = (C.uint16_t)(x.xgmi_link_width), cgoAllocsUnknown
	allocs9356c676.Borrow(cxgmi_link_width_allocs)

	var cxgmi_link_speed_allocs *cgoAllocMap
	ref9356c676.xgmi_link_speed, cxgmi_link_speed_allocs = (C.uint16_t)(x.xgmi_link_speed), cgoAllocsUnknown
	allocs9356c676.Borrow(cxgmi_link_speed_allocs)

	var cpcie_bandwidth_acc_allocs *cgoAllocMap
	ref9356c676.pcie_bandwidth_acc, cpcie_bandwidth_acc_allocs = (C.uint64_t)(x.pcie_bandwidth_acc), cgoAllocsUnknown
	allocs9356c676.Borrow(cpcie_bandwidth_acc_allocs)

	var cpcie_bandwidth_inst_allocs *cgoAllocMap
	ref9356c676.pcie_bandwidth_inst, cpcie_bandwidth_inst_allocs = (C.uint64_t)(x.pcie_bandwidth_inst), cgoAllocsUnknown
	allocs9356c676.Borrow(cpcie_bandwidth_inst_allocs)

	var cpcie_l0_to_recov_count_acc_allocs *cgoAllocMap
	ref9356c676.pcie_l0_to_recov_count_acc, cpcie_l0_to_recov_count_acc_allocs = (C.uint64_t)(x.pcie_l0_to_recov_count_acc), cgoAllocsUnknown
	allocs9356c676.Borrow(cpcie_l0_to_recov_count_acc_allocs)

	var cpcie_replay_count_acc_allocs *cgoAllocMap
	ref9356c676.pcie_replay_count_acc, cpcie_replay_count_acc_allocs = (C.uint64_t)(x.pcie_replay_count_acc), cgoAllocsUnknown
	allocs9356c676.Borrow(cpcie_replay_count_acc_allocs)

	var cpcie_replay_rover_count_acc_allocs *cgoAllocMap
	ref9356c676.pcie_replay_rover_count_acc, cpcie_replay_rover_count_acc_allocs = (C.uint64_t)(x.pcie_replay_rover_count_acc), cgoAllocsUnknown
	allocs9356c676.Borrow(cpcie_replay_rover_count_acc_allocs)

	var cxgmi_read_data_acc_allocs *cgoAllocMap
	ref9356c676.xgmi_read_data_acc, cxgmi_read_data_acc_allocs = *(*[8]C.uint64_t)(unsafe.Pointer(&x.xgmi_read_data_acc)), cgoAllocsUnknown
	allocs9356c676.Borrow(cxgmi_read_data_acc_allocs)

	var cxgmi_write_data_acc_allocs *cgoAllocMap
	ref9356c676.xgmi_write_data_acc, cxgmi_write_data_acc_allocs = *(*[8]C.uint64_t)(unsafe.Pointer(&x.xgmi_write_data_acc)), cgoAllocsUnknown
	allocs9356c676.Borrow(cxgmi_write_data_acc_allocs)

	var ccurrent_gfxclks_allocs *cgoAllocMap
	ref9356c676.current_gfxclks, ccurrent_gfxclks_allocs = *(*[8]C.uint16_t)(unsafe.Pointer(&x.current_gfxclks)), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_gfxclks_allocs)

	var ccurrent_socclks_allocs *cgoAllocMap
	ref9356c676.current_socclks, ccurrent_socclks_allocs = *(*[4]C.uint16_t)(unsafe.Pointer(&x.current_socclks)), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_socclks_allocs)

	var ccurrent_vclk0s_allocs *cgoAllocMap
	ref9356c676.current_vclk0s, ccurrent_vclk0s_allocs = *(*[4]C.uint16_t)(unsafe.Pointer(&x.current_vclk0s)), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_vclk0s_allocs)

	var ccurrent_dclk0s_allocs *cgoAllocMap
	ref9356c676.current_dclk0s, ccurrent_dclk0s_allocs = *(*[4]C.uint16_t)(unsafe.Pointer(&x.current_dclk0s)), cgoAllocsUnknown
	allocs9356c676.Borrow(ccurrent_dclk0s_allocs)

	var cjpeg_activity_allocs *cgoAllocMap
	ref9356c676.jpeg_activity, cjpeg_activity_allocs = *(*[32]C.uint16_t)(unsafe.Pointer(&x.jpeg_activity)), cgoAllocsUnknown
	allocs9356c676.Borrow(cjpeg_activity_allocs)

	var cpcie_nak_sent_count_acc_allocs *cgoAllocMap
	ref9356c676.pcie_nak_sent_count_acc, cpcie_nak_sent_count_acc_allocs = (C.uint32_t)(x.pcie_nak_sent_count_acc), cgoAllocsUnknown
	allocs9356c676.Borrow(cpcie_nak_sent_count_acc_allocs)

	var cpcie_nak_rcvd_count_acc_allocs *cgoAllocMap
	ref9356c676.pcie_nak_rcvd_count_acc, cpcie_nak_rcvd_count_acc_allocs = (C.uint32_t)(x.pcie_nak_rcvd_count_acc), cgoAllocsUnknown
	allocs9356c676.Borrow(cpcie_nak_rcvd_count_acc_allocs)

	x.ref9356c676 = ref9356c676
	x.allocs9356c676 = allocs9356c676
	return ref9356c676, allocs9356c676

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_gpu_metrics) PassValue() (C.rsmi_gpu_metrics_t, *cgoAllocMap) {
	if x.ref9356c676 != nil {
		return *x.ref9356c676, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_gpu_metrics) Deref() {
	if x.ref9356c676 == nil {
		return
	}
	x.common_header = *Newmetrics_table_headerRef(unsafe.Pointer(&x.ref9356c676.common_header))
	x.temperature_edge = (uint16)(x.ref9356c676.temperature_edge)
	x.temperature_hotspot = (uint16)(x.ref9356c676.temperature_hotspot)
	x.temperature_mem = (uint16)(x.ref9356c676.temperature_mem)
	x.temperature_vrgfx = (uint16)(x.ref9356c676.temperature_vrgfx)
	x.temperature_vrsoc = (uint16)(x.ref9356c676.temperature_vrsoc)
	x.temperature_vrmem = (uint16)(x.ref9356c676.temperature_vrmem)
	x.average_gfx_activity = (uint16)(x.ref9356c676.average_gfx_activity)
	x.average_umc_activity = (uint16)(x.ref9356c676.average_umc_activity)
	x.average_mm_activity = (uint16)(x.ref9356c676.average_mm_activity)
	x.average_socket_power = (uint16)(x.ref9356c676.average_socket_power)
	x.energy_accumulator = (uint64)(x.ref9356c676.energy_accumulator)
	x.system_clock_counter = (uint64)(x.ref9356c676.system_clock_counter)
	x.average_gfxclk_frequency = (uint16)(x.ref9356c676.average_gfxclk_frequency)
	x.average_socclk_frequency = (uint16)(x.ref9356c676.average_socclk_frequency)
	x.average_uclk_frequency = (uint16)(x.ref9356c676.average_uclk_frequency)
	x.average_vclk0_frequency = (uint16)(x.ref9356c676.average_vclk0_frequency)
	x.average_dclk0_frequency = (uint16)(x.ref9356c676.average_dclk0_frequency)
	x.average_vclk1_frequency = (uint16)(x.ref9356c676.average_vclk1_frequency)
	x.average_dclk1_frequency = (uint16)(x.ref9356c676.average_dclk1_frequency)
	x.current_gfxclk = (uint16)(x.ref9356c676.current_gfxclk)
	x.current_socclk = (uint16)(x.ref9356c676.current_socclk)
	x.current_uclk = (uint16)(x.ref9356c676.current_uclk)
	x.current_vclk0 = (uint16)(x.ref9356c676.current_vclk0)
	x.current_dclk0 = (uint16)(x.ref9356c676.current_dclk0)
	x.current_vclk1 = (uint16)(x.ref9356c676.current_vclk1)
	x.current_dclk1 = (uint16)(x.ref9356c676.current_dclk1)
	x.throttle_status = (uint32)(x.ref9356c676.throttle_status)
	x.current_fan_speed = (uint16)(x.ref9356c676.current_fan_speed)
	x.pcie_link_width = (uint16)(x.ref9356c676.pcie_link_width)
	x.pcie_link_speed = (uint16)(x.ref9356c676.pcie_link_speed)
	x.gfx_activity_acc = (uint32)(x.ref9356c676.gfx_activity_acc)
	x.mem_activity_acc = (uint32)(x.ref9356c676.mem_activity_acc)
	x.temperature_hbm = *(*[4]uint16)(unsafe.Pointer(&x.ref9356c676.temperature_hbm))
	x.firmware_timestamp = (uint64)(x.ref9356c676.firmware_timestamp)
	x.voltage_soc = (uint16)(x.ref9356c676.voltage_soc)
	x.voltage_gfx = (uint16)(x.ref9356c676.voltage_gfx)
	x.voltage_mem = (uint16)(x.ref9356c676.voltage_mem)
	x.indep_throttle_status = (uint64)(x.ref9356c676.indep_throttle_status)
	x.current_socket_power = (uint16)(x.ref9356c676.current_socket_power)
	x.vcn_activity = *(*[4]uint16)(unsafe.Pointer(&x.ref9356c676.vcn_activity))
	x.gfxclk_lock_status = (uint32)(x.ref9356c676.gfxclk_lock_status)
	x.xgmi_link_width = (uint16)(x.ref9356c676.xgmi_link_width)
	x.xgmi_link_speed = (uint16)(x.ref9356c676.xgmi_link_speed)
	x.pcie_bandwidth_acc = (uint64)(x.ref9356c676.pcie_bandwidth_acc)
	x.pcie_bandwidth_inst = (uint64)(x.ref9356c676.pcie_bandwidth_inst)
	x.pcie_l0_to_recov_count_acc = (uint64)(x.ref9356c676.pcie_l0_to_recov_count_acc)
	x.pcie_replay_count_acc = (uint64)(x.ref9356c676.pcie_replay_count_acc)
	x.pcie_replay_rover_count_acc = (uint64)(x.ref9356c676.pcie_replay_rover_count_acc)
	x.xgmi_read_data_acc = *(*[8]uint64)(unsafe.Pointer(&x.ref9356c676.xgmi_read_data_acc))
	x.xgmi_write_data_acc = *(*[8]uint64)(unsafe.Pointer(&x.ref9356c676.xgmi_write_data_acc))
	x.current_gfxclks = *(*[8]uint16)(unsafe.Pointer(&x.ref9356c676.current_gfxclks))
	x.current_socclks = *(*[4]uint16)(unsafe.Pointer(&x.ref9356c676.current_socclks))
	x.current_vclk0s = *(*[4]uint16)(unsafe.Pointer(&x.ref9356c676.current_vclk0s))
	x.current_dclk0s = *(*[4]uint16)(unsafe.Pointer(&x.ref9356c676.current_dclk0s))
	x.jpeg_activity = *(*[32]uint16)(unsafe.Pointer(&x.ref9356c676.jpeg_activity))
	x.pcie_nak_sent_count_acc = (uint32)(x.ref9356c676.pcie_nak_sent_count_acc)
	x.pcie_nak_rcvd_count_acc = (uint32)(x.ref9356c676.pcie_nak_rcvd_count_acc)
}

// allocRsmi_error_countMemory allocates memory for type C.rsmi_error_count_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_error_countMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_error_countValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_error_countValue = unsafe.Sizeof([1]C.rsmi_error_count_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_error_count) Ref() *C.rsmi_error_count_t {
	if x == nil {
		return nil
	}
	return x.ref7689bfd2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_error_count) Free() {
	if x != nil && x.allocs7689bfd2 != nil {
		x.allocs7689bfd2.(*cgoAllocMap).Free()
		x.ref7689bfd2 = nil
	}
}

// Newrsmi_error_countRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_error_countRef(ref unsafe.Pointer) *rsmi_error_count {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_error_count)
	obj.ref7689bfd2 = (*C.rsmi_error_count_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_error_count) PassRef() (*C.rsmi_error_count_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7689bfd2 != nil {
		return x.ref7689bfd2, nil
	}
	mem7689bfd2 := allocRsmi_error_countMemory(1)
	ref7689bfd2 := (*C.rsmi_error_count_t)(mem7689bfd2)
	allocs7689bfd2 := new(cgoAllocMap)
	allocs7689bfd2.Add(mem7689bfd2)

	var ccorrectable_err_allocs *cgoAllocMap
	ref7689bfd2.correctable_err, ccorrectable_err_allocs = (C.uint64_t)(x.correctable_err), cgoAllocsUnknown
	allocs7689bfd2.Borrow(ccorrectable_err_allocs)

	var cuncorrectable_err_allocs *cgoAllocMap
	ref7689bfd2.uncorrectable_err, cuncorrectable_err_allocs = (C.uint64_t)(x.uncorrectable_err), cgoAllocsUnknown
	allocs7689bfd2.Borrow(cuncorrectable_err_allocs)

	x.ref7689bfd2 = ref7689bfd2
	x.allocs7689bfd2 = allocs7689bfd2
	return ref7689bfd2, allocs7689bfd2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_error_count) PassValue() (C.rsmi_error_count_t, *cgoAllocMap) {
	if x.ref7689bfd2 != nil {
		return *x.ref7689bfd2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_error_count) Deref() {
	if x.ref7689bfd2 == nil {
		return
	}
	x.correctable_err = (uint64)(x.ref7689bfd2.correctable_err)
	x.uncorrectable_err = (uint64)(x.ref7689bfd2.uncorrectable_err)
}

// allocRsmi_process_infoMemory allocates memory for type C.rsmi_process_info_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_process_infoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_process_infoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_process_infoValue = unsafe.Sizeof([1]C.rsmi_process_info_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_process_info) Ref() *C.rsmi_process_info_t {
	if x == nil {
		return nil
	}
	return x.ref3e0d7669
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_process_info) Free() {
	if x != nil && x.allocs3e0d7669 != nil {
		x.allocs3e0d7669.(*cgoAllocMap).Free()
		x.ref3e0d7669 = nil
	}
}

// Newrsmi_process_infoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_process_infoRef(ref unsafe.Pointer) *rsmi_process_info {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_process_info)
	obj.ref3e0d7669 = (*C.rsmi_process_info_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_process_info) PassRef() (*C.rsmi_process_info_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e0d7669 != nil {
		return x.ref3e0d7669, nil
	}
	mem3e0d7669 := allocRsmi_process_infoMemory(1)
	ref3e0d7669 := (*C.rsmi_process_info_t)(mem3e0d7669)
	allocs3e0d7669 := new(cgoAllocMap)
	allocs3e0d7669.Add(mem3e0d7669)

	var cprocess_id_allocs *cgoAllocMap
	ref3e0d7669.process_id, cprocess_id_allocs = (C.uint32_t)(x.process_id), cgoAllocsUnknown
	allocs3e0d7669.Borrow(cprocess_id_allocs)

	var cpasid_allocs *cgoAllocMap
	ref3e0d7669.pasid, cpasid_allocs = (C.uint32_t)(x.pasid), cgoAllocsUnknown
	allocs3e0d7669.Borrow(cpasid_allocs)

	var cvram_usage_allocs *cgoAllocMap
	ref3e0d7669.vram_usage, cvram_usage_allocs = (C.uint64_t)(x.vram_usage), cgoAllocsUnknown
	allocs3e0d7669.Borrow(cvram_usage_allocs)

	var csdma_usage_allocs *cgoAllocMap
	ref3e0d7669.sdma_usage, csdma_usage_allocs = (C.uint64_t)(x.sdma_usage), cgoAllocsUnknown
	allocs3e0d7669.Borrow(csdma_usage_allocs)

	var ccu_occupancy_allocs *cgoAllocMap
	ref3e0d7669.cu_occupancy, ccu_occupancy_allocs = (C.uint32_t)(x.cu_occupancy), cgoAllocsUnknown
	allocs3e0d7669.Borrow(ccu_occupancy_allocs)

	x.ref3e0d7669 = ref3e0d7669
	x.allocs3e0d7669 = allocs3e0d7669
	return ref3e0d7669, allocs3e0d7669

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_process_info) PassValue() (C.rsmi_process_info_t, *cgoAllocMap) {
	if x.ref3e0d7669 != nil {
		return *x.ref3e0d7669, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_process_info) Deref() {
	if x.ref3e0d7669 == nil {
		return
	}
	x.process_id = (uint32)(x.ref3e0d7669.process_id)
	x.pasid = (uint32)(x.ref3e0d7669.pasid)
	x.vram_usage = (uint64)(x.ref3e0d7669.vram_usage)
	x.sdma_usage = (uint64)(x.ref3e0d7669.sdma_usage)
	x.cu_occupancy = (uint32)(x.ref3e0d7669.cu_occupancy)
}

// allocRsmi_func_id_iter_handleMemory allocates memory for type C.rsmi_func_id_iter_handle_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRsmi_func_id_iter_handleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRsmi_func_id_iter_handleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRsmi_func_id_iter_handleValue = unsafe.Sizeof([1]C.rsmi_func_id_iter_handle_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *rsmi_func_id_iter_handle) Ref() *C.rsmi_func_id_iter_handle_t {
	if x == nil {
		return nil
	}
	return x.ref5ba822f7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *rsmi_func_id_iter_handle) Free() {
	if x != nil && x.allocs5ba822f7 != nil {
		x.allocs5ba822f7.(*cgoAllocMap).Free()
		x.ref5ba822f7 = nil
	}
}

// Newrsmi_func_id_iter_handleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newrsmi_func_id_iter_handleRef(ref unsafe.Pointer) *rsmi_func_id_iter_handle {
	if ref == nil {
		return nil
	}
	obj := new(rsmi_func_id_iter_handle)
	obj.ref5ba822f7 = (*C.rsmi_func_id_iter_handle_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *rsmi_func_id_iter_handle) PassRef() (*C.rsmi_func_id_iter_handle_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ba822f7 != nil {
		return x.ref5ba822f7, nil
	}
	mem5ba822f7 := allocRsmi_func_id_iter_handleMemory(1)
	ref5ba822f7 := (*C.rsmi_func_id_iter_handle_t)(mem5ba822f7)
	allocs5ba822f7 := new(cgoAllocMap)
	allocs5ba822f7.Add(mem5ba822f7)

	x.ref5ba822f7 = ref5ba822f7
	x.allocs5ba822f7 = allocs5ba822f7
	return ref5ba822f7, allocs5ba822f7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x rsmi_func_id_iter_handle) PassValue() (C.rsmi_func_id_iter_handle_t, *cgoAllocMap) {
	if x.ref5ba822f7 != nil {
		return *x.ref5ba822f7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *rsmi_func_id_iter_handle) Deref() {
	if x.ref5ba822f7 == nil {
		return
	}
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}
